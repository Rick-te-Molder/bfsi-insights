# BFSI Insights Coding Practices

This file contains project-specific coding rules for AI assistants (Windsurf/Cursor).
These rules are learned from bugs, incidents, and code reviews.

---

## Data Consistency

### Pipeline Status Queries (KB-202)
- **Always use `status_code`** (numeric) for pipeline status queries, never `status` (text)
- **Load status codes from the `status_lookup` table** — this is the single source of truth
- Never hardcode status code values; query `status_lookup` at runtime
- See `docs/architecture/pipeline-status-codes.md` for documentation
- Reference implementation: `services/agent-api/src/lib/status-codes.js`

### Query Pattern Consistency
- Dashboard and all UI views must use **identical query logic** for the same data
- No client-side filtering that duplicates or contradicts DB-level filters
- When adding a new view of existing data, check how other views query it first

---

## TypeScript / React

### Unused Variables
- Prefix intentionally unused variables with `_` (e.g., `status: _status`)
- Remove truly unused imports/variables rather than prefixing

### React Hooks
- Define `useCallback` handlers **before** `useEffect` hooks that reference them
- Include all dependencies in useEffect/useCallback dependency arrays
- Use `useMemo` for expensive computations, with eslint-disable if needed for impure functions

### Component Props
- Keep prop names consistent across interface and destructuring
- Use `propName: _propName` syntax when prop is required but unused locally

---

## Linting (KB-204)

### Strict Policy: Zero Errors AND Zero Warnings
- Run `npm run lint` in admin-next before every commit
- **Must pass with 0 errors AND 0 warnings**
- Fix all warnings, don't just leave them

### Exception Process
If a warning cannot be fixed (e.g., third-party library issue, intentional pattern):
1. **STOP and ask user for approval** before committing
2. Explain: what the warning is, why it can't be fixed, what the risk is
3. User must explicitly approve skipping the warning
4. If approved, add `eslint-disable` with a comment explaining why

### eslint-disable Rules
- Never add eslint-disable without user approval or clear justification
- Always include a comment explaining why the disable is needed
- Prefer fixing the issue over disabling the rule

---

## Git Workflow

- Never commit directly to main
- Branch naming: `feat/kb-XXX-desc`, `fix/kb-XXX-desc`, `improve/kb-XXX-desc`
- Include Linear issue ID in commits: `fix(KB-XXX): description`
- Create PR immediately after first push to start CI

### Pre-Commit & Push Checks (KB-280, KB-285)
**BEFORE every `git commit`, verify:**
1. Run `git branch` — confirm you're on the correct feature branch, not `main`
2. Run `gh pr view <NUMBER> --json state` — if PR exists, confirm it's not merged
   - If **merged**: STOP. Create new branch from main
   - If **open** or **no PR yet**: Safe to proceed
3. Run `npm run lint` in admin-next — must pass with 0 errors and 0 warnings

**Why:** Prevents commits to wrong branch, orphan commits to merged branches, and lint failures in CI.

---

## Adding New Rules

When you encounter a bug or incident:
1. Identify the **root cause pattern** (not just the symptom)
2. Add a rule here that would have prevented it
3. Include the Linear issue ID for context (e.g., KB-202)

---

## Database Schema

### Primary Keys
- **Always use UUID** as primary key for new tables (not serial integers or text slugs)
- Use `gen_random_uuid()` as default value
- Text slugs (like `name`) should be unique constraints, not primary keys
- Example: `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`

### Single Source of Truth
- Define business concepts (audiences, statuses, etc.) in ONE table
- LLM prompts should reference these tables, not hardcode definitions
- When updating a concept, update the source table - prompts pull dynamically

---

## Prompt Engineering (KB-207)

### Agent Registry
- Every agent must be declared in `docs/agents/manifest.yaml`
- Manifest defines required prompts and tables for each agent
- CI validates prompt coverage on every PR

### Prompt Changes
- Every prompt change requires a migration file in `supabase/migrations/`
- Use `INSERT ... ON CONFLICT` pattern for safe updates
- Set `is_current = true` for new version, `false` for old versions
- Include `notes` explaining what changed and why

### Fail-Fast Policy
- Agents must throw errors if required prompts are missing
- No silent fallbacks to hardcoded prompts
- Use `throw new Error('CRITICAL: ...')` pattern from KB-206

### Dynamic Prompts
- Business concept definitions (audiences, taxonomies) should be in DB tables
- Prompts should load definitions from tables, not hardcode them
- Example: `kb_audience` table contains scoring guides loaded by discovery-relevance

### Prompt Version Migrations (KB-258)
- **Always INSERT new rows** for prompt versions, never UPDATE existing rows
- UPDATE keeps original `created_at`, causing incorrect version history
- Pattern:
  ```sql
  -- Mark old as not current
  UPDATE prompt_version SET is_current = false WHERE agent_name = 'X' AND is_current = true;
  -- INSERT new version
  INSERT INTO prompt_version (agent_name, version, prompt_text, is_current, notes) VALUES (...);

---

## Taxonomy & Tags (KB-219)

### Use taxonomy_config for dynamic tag insertion
- **Never hardcode tag types** in approve handlers
- Always query `taxonomy_config` table for junction table mappings
- Pattern:
  ```typescript
  const { data: configs } = await supabase
    .from('taxonomy_config')
    .select('payload_field, junction_table, junction_code_column')
    .eq('is_active', true)
    .not('junction_table', 'is', null);
  
  for (const config of configs) {
    const codes = payload[config.payload_field];
    if (codes?.length) {
      await supabase.from(config.junction_table).insert(...);
    }
  }
  ---

## Code Quality (KB-151)

### Boy Scout Rule: Leave code cleaner than you found it
- **All touched files must meet SIG guidelines** - no exceptions
- Files MUST be < 300 lines
- Functions MUST be < 30 lines (SHOULD be < 15 lines)
- Pre-commit hook ([scripts/check-large-files.cjs](cci:7://file:///Users/micro/projects/bfsi-insights/scripts/check-large-files.cjs:0:0-0:0)) enforces this strictly
- 148 files have known violations - must refactor when touched
- See [docs/architecture/coding-practices.md](cci:7://file:///Users/micro/projects/bfsi-insights/docs/architecture/coding-practices.md:0:0-0:0) for detailed guidance

### When blocked by large file/function violations:
1. Extract helper functions to separate modules
2. Split large files into multiple focused files
3. Use single-responsibility principle
4. Name functions descriptively for what they do
5. See coding-practices.md for refactoring examples

### Known Violations (as of 2026-01-02)
- 31 files > 300 lines
- ~117 files with functions > 30 lines
- See `ALLOW_LIST` in [scripts/check-large-files.cjs](cci:7://file:///Users/micro/projects/bfsi-insights/scripts/check-large-files.cjs:0:0-0:0) for tracking
- These files WILL block commits when modified

### Why
- Maintainability: Smaller units are easier to understand
- Testability: Focused functions are easier to test
- Reusability: Small functions can be reused
- Code Review: Easier to review small changes
  ```
