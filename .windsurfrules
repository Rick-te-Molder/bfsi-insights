# BFSI Insights Coding Practices (.windsurfrules)

Project-specific rules for AI assistants (Windsurf/Cursor).
These rules exist because bugs, incidents, and CI failures happened.

---

## Data Consistency

### Pipeline Status Queries (KB-202)
- Always use `status_code` (numeric) for pipeline status queries, never `status` (text).
- Load status codes from the `status_lookup` table (single source of truth).
- Never hardcode status code values; query `status_lookup` at runtime.
- Reference: `services/agent-api/src/lib/status-codes.js`
- Docs: `docs/architecture/pipeline-status-codes.md`

### Query Pattern Consistency
- Dashboard and all UI views must use identical query logic for the same data.
- No client-side filtering that duplicates or contradicts DB-level filters.
- When adding a new view of existing data, check how other views query it first.

---

## TypeScript / React

### Unused Variables
- Prefix intentionally unused variables with `_` (e.g., `status: _status`).
- Remove truly unused imports/variables rather than prefixing.

### React Hooks
- Define `useCallback` handlers before `useEffect` hooks that reference them.
- Include all dependencies in dependency arrays.
- Use `useMemo` for expensive computations (eslint-disable only with justification).

### Component Props
- Keep prop names consistent across interface and destructuring.
- Use `propName: _propName` when required but unused locally.

---

## Linting (KB-204)

### Strict Policy: Zero Errors AND Zero Warnings
- Run `npm run lint` in `admin-next` before every commit.
- Must pass with 0 errors AND 0 warnings.

### Exception Process
If a warning cannot be fixed:
1. Stop and ask user for approval before committing.
2. Explain: warning, why it can’t be fixed, risk.
3. If approved: add `eslint-disable` with a comment explaining why.

---

## Git Workflow (PRs re-enabled)

### Core rules
- Never commit directly to `main`.
- Use feature branches.
- PRs are required for merging into `main`.

### Branch naming
- `feat/kb-XXX-desc`
- `fix/kb-XXX-desc`
- `improve/kb-XXX-desc`
- If no KB exists yet, use `feat/misc-desc` / `fix/misc-desc`.

### Commit message
- Prefer: `fix(KB-XXX): description` / `feat(KB-XXX): description`
- If no KB: `fix: description` / `feat: description`

### PR discipline
- One concern per PR (small diffs only).
- If multiple concerns exist, split into multiple PRs.
- Keep PRs short-lived; rebase when needed.

---

## CI Strategy: Fast vs Slow

### Fast CI (runs on PRs)
Fast CI is the gate for merging.
It must be quick and deterministic.

Fast CI should include:
- Lint (admin-next, and any other lint jobs you maintain)
- Unit tests + coverage (especially `services/agent-api`)
- Build checks (e.g., Next/Astro build)
- Typecheck (if separate)

Fast CI must NOT include:
- Supabase CLI jobs that hit network or remote DB
- Schema doc generation
- Long-running integration/E2E
- Heavy scans that are slow/flaky

### Slow CI (runs on main or schedule)
Slow CI can be:
- `push` to `main` (post-merge), and/or
- scheduled (nightly), and/or
- manual (`workflow_dispatch`)

Slow CI can include:
- Supabase lint / remote DB checks
- Schema docs update
- E2E / Playwright
- SonarCloud full analysis if it’s slow
- Any job known to be flaky due to external dependencies

### Rules for changes that touch CI
- When editing workflows, explicitly state whether the change affects Fast CI, Slow CI, or both.
- Prefer moving flaky/network-heavy steps to Slow CI rather than “continue-on-error” in Fast CI.

---

## Pre-commit & local verification

### Before every commit
1. Confirm you are on a feature branch (not `main`).
2. Run `npm run lint` in `admin-next` (0 errors, 0 warnings).

### For agent-api test/coverage work
Run and paste relevant excerpts from:
- `npm run test:coverage -w services/agent-api`
- plus a targeted grep/coverage proof for the touched files (example: `grep -E "^\s*replay\.js\s+\|"`)

---

## Prompt Engineering (KB-207)

### Agent Registry
- Every agent must be declared in `docs/agents/manifest.yaml`.
- CI validates prompt coverage on every PR.

### Prompt Changes
- Every prompt change requires a migration in `supabase/migrations/`.
- Use `INSERT ... ON CONFLICT` pattern for safe updates when applicable.
- Set `is_current = true` for new version, `false` for old versions.
- Include `notes` explaining what changed and why.

### Fail-Fast Policy
- Agents must throw errors if required prompts are missing.
- No silent fallbacks to hardcoded prompts.
- Use `throw new Error('CRITICAL: ...')` pattern from KB-206.

### Prompt Version Migrations (KB-258)
- Always INSERT new rows for prompt versions, never UPDATE existing rows.
- Pattern:
  ```sql
  UPDATE prompt_version SET is_current = false
  WHERE agent_name = 'X' AND is_current = true;

  INSERT INTO prompt_version (agent_name, version, prompt_text, is_current, notes)
  VALUES (...);


⸻

Taxonomy & Tags (KB-219)

Use taxonomy_config for dynamic tag insertion
	•	Never hardcode tag types in approve handlers.
	•	Always query taxonomy_config for junction mappings.
	•	Pattern:

const { data: configs } = await supabase
  .from('taxonomy_config')
  .select('payload_field, junction_table, junction_code_column')
  .eq('is_active', true)
  .not('junction_table', 'is', null);

for (const config of configs) {
  const codes = payload[config.payload_field];
  if (codes?.length) {
    await supabase.from(config.junction_table).insert(...);
  }
}



⸻

Code Quality (KB-151)

Boy Scout Rule
	•	All touched files must meet SIG guidelines (no exceptions).
	•	Files must be < 300 lines.
	•	Functions must be < 30 lines (should be < 15).
	•	Pre-commit hook enforces this: scripts/check-large-files.cjs
	•	Known violations are tracked in ALLOW_LIST inside that script.

⸻

Hard rules for all changes (no exceptions)
	1.	No claims without evidence

	•	Do not say “fixed”, “works”, “tests pass”, “coverage improved”, “CI is green”, etc.
unless you include quoted evidence from command output or CI logs.
	•	If you cannot produce evidence, state exactly what is unverified.

	2.	Small diffs only

	•	One concern per change/commit/PR.
	•	Split multiple concerns into separate PRs.

	3.	Verify locally before responding

	•	For test/coverage work in services/agent-api, run and paste relevant excerpts:
	•	npm run test:coverage -w services/agent-api
	•	and a targeted grep proof for touched files.
	•	For CI workflow edits, paste the literal unified diff of the workflow change.

⸻

Required response format for “done” messages
	•	Evidence:
	•	<paste command output / CI log lines>
	•	Diff summary:
	•	<files changed + why>
	•	Remaining risks / unverified:
	•	<explicit list, or “none”>

